"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования Решета Эратосфена;
Использовать алгоритм решето Эратосфена
"""
from timeit import timeit


def eratosphen(u_num, fin_num=300):
    # заполнение списка числами так, чтобы в нем было заведомо не менее user_number простых чисел
    # начинаем с 2 - первого простого числа
    prime_list = [number for number in range(fin_num+1)]
    prime_list[1] = 0                        # 1 не относится к простым числам
    primes = []
    for idx in range(2, fin_num + 1):  # перебор всех элементов от 2 до верхней границы
        if prime_list[idx] != 0:  # если элемент не равен нулю, то
            primes.append(prime_list[idx])  # добавляем его в результирующий список
            for idx_2 in range(idx * 2, fin_num + 1, idx):  # увеличиваем idx вдвое и все кратные idx числа обнуляем
                prime_list[idx_2] = 0
    # возвращаем элемент с номером u_num-1 - искомый элемент
    return primes[u_num-1]


def prime_number(u_num, fin_num=300):
    primes = [2]
    for number in range(3, fin_num + 1, 2):
        if number > 10 and number % 5 == 0:
            continue
        primes.append(number)
        for checker in primes[:-1]:
            if number % checker == 0:
                primes.pop(-1)
                break
        if len(primes) == u_num:
            break
    return primes[u_num-1]


user_number = int(input("Введите номер порядковый простого числа: "))
u_num = user_number
print('Вариант 1 (Решето Эратосфена)')
print(f'Простое число с порядковым номером {user_number}: {eratosphen(user_number)}')
print(f'Время нахождения простого числа с порядковым номером {user_number} :'
      f' {timeit("eratosphen(u_num)", setup="from __main__ import eratosphen, u_num", number=1000)}')
print('Вариант 2 (Без использования Решета Эратосфена)')
print(f'Простое число с порядковым номером {user_number}: {prime_number(user_number)}')
print(f'Время нахождения простого числа с порядковым номером {user_number} :'
      f' {timeit("prime_number(u_num)", setup="from __main__ import prime_number, u_num", number=1000)}')

"""
Сложность алгоритма в варианте 1 - O(n2) - два вложенных цикла, время операции для 5го простого - 0.0919 мс,
для 55го простого - 0.0885 мс
Сложность алгоритма в варианте 2 - O(n2) - два вложенных цикла, время операции для 5го простого - 0.0037 мс,
для 55го простого - 0.1748 мс
Чем ближе искомое простое число к верхней границе, тем эффективнее работает Решето Эратосфена, так как
главное преимущество варианта 2 - не создается список всех чисел, из которого потом отсеиваются составные, а список
формируетсядо тех пор, пока в итоговом списке не окажется элементов, количеством u_num, результатом является последний
элемент итогового списка.
Очевидно, что если бы нужно было искать не i-е по счету простое число, а формировать список простых чисел из i
элементов, алгоритм с использованием Решета Эратосфена показал бы намного лучшую производительность по времени, так как 
преимущество варианта 2 полностью исчезло бы - в обоих случаях формировался бы и обрабатывался список из i элементов
"""
